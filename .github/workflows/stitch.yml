name: Stitch video from Google Drive

on:
  workflow_dispatch:
    inputs:
      input_filename:
        description: "Nombre del v√≠deo principal (como lo ves en Drive; con o sin extensi√≥n o un fragmento)"
        required: true
      intro_filename:
        description: "Nombre de la intro en la carpeta origen"
        default: "intro.mp4"
      outro_filename:
        description: "Nombre del cierre en la carpeta origen"
        default: "outro.mp4"
      output_basename:
        description: "Nombre base del archivo de salida (sin .mp4)"
        default: "salida"

jobs:
  stitch:
    runs-on: ubuntu-latest
    timeout-minutes: 350

    steps:
      - name: Enmascarar inputs (por si aparecieran)
        run: |
          echo "::add-mask::${{ inputs.input_filename }}"
          echo "::add-mask::${{ inputs.intro_filename }}"
          echo "::add-mask::${{ inputs.outro_filename }}"

      - name: Instalar ffmpeg, rclone y jq
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq
          curl -fsSL https://rclone.org/install.sh | sudo bash

      - name: Configurar rclone con Service Account y ra√≠z ORIGEN (secrets)
        env:
          SA_JSON: ${{ secrets.GDRIVE_SA_JSON }}
          SRC_ID: ${{ secrets.DRIVE_SRC_ID }}
        run: |
          set -e
          umask 077
          printf '%s' "$SA_JSON" > sa.json
          cat > rclone.conf <<'EOF'
          [gdrive]
          type = drive
          scope = drive
          service_account_file = ./sa.json
          root_folder_id = __ROOT__
          EOF
          perl -0777 -pe 's/__ROOT__/$ENV{"SRC_ID"}/g' -i rclone.conf

      - name: Preflight (acceso a ORIGEN/DESTINO)
        env:
          RCLONE_CONFIG: ${{ github.workspace }}/rclone.conf
          DST_ID: ${{ secrets.DRIVE_DST_ID }}
        run: |
          set -e
          rclone lsf gdrive: --max-depth 0 --log-level ERROR >/dev/null || { echo "‚ùå No puedo listar ORIGEN"; exit 3; }
          if [ -n "$DST_ID" ]; then
            cp "$RCLONE_CONFIG" rclone.dst.conf
            perl -0777 -pe 's/(^root_folder_id = ).*/${1}$ENV{"DST_ID"}/m' -i rclone.dst.conf
            RCLONE_CONFIG=$(pwd)/rclone.dst.conf rclone lsf gdrive: --max-depth 0 --log-level ERROR >/dev/null || { echo "‚ùå No puedo listar DESTINO"; exit 4; }
          fi
          echo "‚úÖ Preflight OK"

      - name: Listado visible de archivos en ORIGEN (no se imprime el ID)
        env:
          RCLONE_CONFIG: ${{ github.workspace }}/rclone.conf
        run: |
          set -e
          echo "üìÑ Contenido (s√≥lo archivos) en la carpeta ORIGEN:"
          rclone lsf gdrive: --files-only --log-level ERROR | sed 's/^/ - /'

      - name: Resolver nombres (tolerante a extensi√≥n, slashes y espacios)
        id: resolve
        env:
          RCLONE_CONFIG: ${{ github.workspace }}/rclone.conf
          IN_NAME: ${{ inputs.input_filename }}
          INTRO_NAME: ${{ inputs.intro_filename }}
          OUTRO_NAME: ${{ inputs.outro_filename }}
        run: |
          set -e
          # Listado JSON
          rclone lsjson gdrive: --files-only --log-level ERROR > files.json
          echo "‚ÑπÔ∏è Total archivos detectados en ORIGEN: $(jq 'length' files.json)"

          # Normalizaci√≥n: convierte el slash "Ôºè" (U+FF0F) a "/", colon "Ôºö" (U+FF1A) a ":" y colapsa espacios
          norm_shell() {
            # $1 -> cadena
            printf '%s' "$1" | sed -e 's/Ôºè/\//g' -e 's/Ôºö/:/g' -e 's/[[:space:]]\+/ /g' -e 's/^ *//; s/ *$//'
          }

          NEEDLE_RAW="$IN_NAME"
          NEEDLE_NORM="$(norm_shell "$IN_NAME")"
          echo "üîé Buscando input por: '$NEEDLE_RAW'  (normalizado: '$NEEDLE_NORM')"

          # Resolver en jq con scoring
          resolve() {
            local needle="$1"
            jq -r --arg in "$needle" '
              def norm(s):
                (s
                 | gsub("\uFF0F";"/")
                 | gsub("\uFF1A";":")
                 | gsub("\\s+";" ")
                 | sub("^\\s+";"")
                 | sub("\\s+$";"")
                 | ascii_downcase);
              def base(s): s|sub("\\.[^.]*$";"");
              [ .[] | select(.IsDir!=true) | .Name as $n |
                {
                  n: $n,
                  score:
                    (if norm($n) == norm($in) then 400 else 0 end) +
                    (if norm(base($n)) == norm($in) then 300 else 0 end) +
                    (if (norm($n) | startswith(norm($in))) then 200 else 0 end) +
                    (if (norm($n) | contains(norm($in))) then 100 else 0 end) +
                    (if ($n | endswith("Recording") or ($n|test("\\.mp4$"))) then 10 else 0 end)
                }
              ]
              | (max_by(.score)|.n // "")
            ' files.json
          }

          # Resuelve input con needle normalizado (para salvar / vs Ôºè, espacios, etc.)
          RES_INPUT="$(resolve "$NEEDLE_NORM")"
          # Resuelve intro/outro tal cual
          RES_INTRO="$(resolve "$(norm_shell "$INTRO_NAME")")"
          RES_OUTRO="$(resolve "$(norm_shell "$OUTRO_NAME")")"

          if [ -z "$RES_INPUT" ]; then
            echo "‚ùå No encuentro el archivo de ENTRADA que corresponda a: '$IN_NAME'"
            echo "   (normalizado: '$NEEDLE_NORM')"
            echo "üëâ Revisa el listado anterior. Puedes pasar un fragmento distintivo del nombre."
            exit 5
          fi
          if [ -z "$RES_INTRO" ]; then
            echo "‚ùå No encuentro la INTRO: '$INTRO_NAME'"
            exit 5
          fi
          if [ -z "$RES_OUTRO" ]; then
            echo "‚ùå No encuentro el OUTRO: '$OUTRO_NAME'"
            exit 5
          fi

          echo "input_resuelto=$RES_INPUT" >> $GITHUB_OUTPUT
          echo "intro_resuelto=$RES_INTRO" >> $GITHUB_OUTPUT
          echo "outro_resuelto=$RES_OUTRO" >> $GITHUB_OUTPUT

          echo "‚úÖ Resueltos:"
          echo " - Input: $RES_INPUT"
          echo " - Intro: $RES_INTRO"
          echo " - Outro: $RES_OUTRO"

      - name: Descargar fuentes desde Drive
        env:
          RCLONE_CONFIG: ${{ github.workspace }}/rclone.conf
        run: |
          set -e
          mkdir -p in
          rclone copy "gdrive:${{ steps.resolve.outputs.input_resuelto }}" in/ --log-level ERROR
          rclone copy "gdrive:${{ steps.resolve.outputs.intro_resuelto }}"  in/ --log-level ERROR
          rclone copy "gdrive:${{ steps.resolve.outputs.outro_resuelto }}"  in/ --log-level ERROR

      - name: Detectar par√°metros del v√≠deo principal
        id: probe
        run: |
          set -e
          VFILE="in/${{ steps.resolve.outputs.input_resuelto }}"
          V_CODEC=$(ffprobe -v error -select_streams v:0 -show_entries stream=codec_name -of csv=p=0 "$VFILE")
          WIDTH=$(ffprobe -v error -select_streams v:0 -show_entries stream=width -of csv=p=0 "$VFILE")
          HEIGHT=$(ffprobe -v error -select_streams v:0 -show_entries stream=height -of csv=p=0 "$VFILE")
          FPS_R=$(ffprobe -v error -select_streams v:0 -show_entries stream=r_frame_rate -of csv=p=0 "$VFILE")
          A_CODEC=$(ffprobe -v error -select_streams a:0 -show_entries stream=codec_name -of csv=p=0 "$VFILE" || echo "aac")
          A_SR=$(ffprobe -v error -select_streams a:0 -show_entries stream=sample_rate -of csv=p=0 "$VFILE" || echo "48000")
          A_CH=$(ffprobe -v error -select_streams a:0 -show_entries stream=channels -of csv=p=0 "$VFILE" || echo "2")
          case "$V_CODEC" in
            h264) VLIB=libx264 ;;
            hevc|h265) VLIB=libx265; V_CODEC=hevc ;;
            *) VLIB=libx264; V_CODEC=h264 ;;
          esac
          case "$A_CODEC" in
            aac) ALIB=aac ;; mp3) ALIB=libmp3lame ;; opus) ALIB=libopus ;; *) ALIB=aac; A_CODEC=aac ;;
          esac
          echo "vcodec=$V_CODEC" >> $GITHUB_OUTPUT
          echo "vlib=$VLIB"      >> $GITHUB_OUTPUT
          echo "width=$WIDTH"    >> $GITHUB_OUTPUT
          echo "height=$HEIGHT"  >> $GITHUB_OUTPUT
          echo "fpsr=$FPS_R"     >> $GITHUB_OUTPUT
          echo "acodec=$A_CODEC" >> $GITHUB_OUTPUT
          echo "alib=$ALIB"      >> $GITHUB_OUTPUT
          echo "asr=$A_SR"       >> $GITHUB_OUTPUT
          echo "ach=$A_CH"       >> $GITHUB_OUTPUT

      - name: Adaptar SOLO intro y outro al principal (para favorecer -c copy)
        run: |
          set -e
          VLIB='${{ steps.probe.outputs.vlib }}'
          WIDTH='${{ steps.probe.outputs.width }}'
          HEIGHT='${{ steps.probe.outputs.height }}'
          FPSR='${{ steps.probe.outputs.fpsr }}'
          ALIB='${{ steps.probe.outputs.alib }}'
          ASR='${{ steps.probe.outputs.asr }}'
          ACH='${{ steps.probe.outputs.ach }}'

          ffmpeg -hide_banner -loglevel error -y -i "in/${{ steps.resolve.outputs.intro_resuelto }}" \
            -vf "scale=${WIDTH}:${HEIGHT}:force_original_aspect_ratio=decrease,pad=${WIDTH}:${HEIGHT}:(ow-iw)/2:(oh-ih)/2" \
            -r "$FPSR" -c:v "$VLIB" -pix_fmt yuv420p -c:a "$ALIB" -ar "$ASR" -ac "$ACH" intro_t.mp4

          ffmpeg -hide_banner -loglevel error -y -i "in/${{ steps.resolve.outputs.outro_resuelto }}" \
            -vf "scale=${WIDTH}:${HEIGHT}:force_original_aspect_ratio=decrease,pad=${WIDTH}:${HEIGHT}:(ow-iw)/2:(oh-ih)/2" \
            -r "$FPSR" -c:v "$VLIB" -pix_fmt yuv420p -c:a "$ALIB" -ar "$ASR" -ac "$ACH" outro_t.mp4

      - name: Concatenar (sin recodificar el cuerpo; fallback si falla)
        run: |
          set -e
          printf "file 'intro_t.mp4'\nfile 'in/${{ steps.resolve.outputs.input_resuelto }}'\nfile 'outro_t.mp4'\n" > list.txt
          if ffmpeg -hide_banner -loglevel error -f concat -safe 0 -i list.txt -c copy out.mp4; then
            echo "Concat -c copy OK"
          else
            echo "Param mismatch; recodificando todo (tardar√° m√°s)"
            ffmpeg -hide_banner -loglevel error -f concat -safe 0 -i list.txt \
              -c:v libx264 -preset veryfast -crf 20 -c:a aac -b:a 128k out.mp4
          fi

      - name: Subir salida a Drive DESTINO (o a ORIGEN si no hay destino)
        env:
          RCLONE_CONFIG: ${{ github.workspace }}/rclone.conf
          DST_ID: ${{ secrets.DRIVE_DST_ID }}
        run: |
          set -e
          OUT="${{ inputs.output_basename }}.mp4"
          if [ -n "$DST_ID" ]; then
            cp "$RCLONE_CONFIG" rclone.dst.conf
            perl -0777 -pe 's/(^root_folder_id = ).*/${1}$ENV{"DST_ID"}/m' -i rclone.dst.conf
            RCLONE_CONFIG=$(pwd)/rclone.dst.conf rclone copyto out.mp4 "gdrive:${OUT}" --log-level ERROR
          else
            rclone copyto out.mp4 "gdrive:${OUT}" --log-level ERROR
          fi
