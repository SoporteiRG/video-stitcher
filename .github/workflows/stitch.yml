name: Stitch video from Google Drive

on:
  workflow_dispatch:
    inputs:
      input_filename:
        description: "Nombre del v√≠deo principal (como lo ves en Drive; con o sin extensi√≥n)"
        required: true
      intro_filename:
        description: "Nombre de la intro en la carpeta origen"
        default: "intro.mp4"
      outro_filename:
        description: "Nombre del cierre en la carpeta origen"
        default: "outro.mp4"
      output_basename:
        description: "Nombre base del archivo de salida (sin .mp4)"
        default: "salida"

jobs:
  stitch:
    runs-on: ubuntu-latest
    timeout-minutes: 350

    steps:
      - name: Enmascarar inputs (por si aparecieran)
        run: |
          echo "::add-mask::${{ inputs.input_filename }}"
          echo "::add-mask::${{ inputs.intro_filename }}"
          echo "::add-mask::${{ inputs.outro_filename }}"

      - name: Instalar ffmpeg, rclone y jq
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq
          curl -fsSL https://rclone.org/install.sh | sudo bash

      - name: Configurar rclone con Service Account y ra√≠z ORIGEN (secrets)
        env:
          SA_JSON: ${{ secrets.GDRIVE_SA_JSON }}
          SRC_ID: ${{ secrets.DRIVE_SRC_ID }}
        run: |
          set -e
          umask 077
          printf '%s' "$SA_JSON" > sa.json
          cat > rclone.conf <<'EOF'
          [gdrive]
          type = drive
          scope = drive
          service_account_file = ./sa.json
          root_folder_id = __ROOT__
          EOF
          perl -0777 -pe 's/__ROOT__/$ENV{"SRC_ID"}/g' -i rclone.conf

      - name: Preflight (acceso a ORIGEN/DESTINO)
        env:
          RCLONE_CONFIG: ${{ github.workspace }}/rclone.conf
          DST_ID: ${{ secrets.DRIVE_DST_ID }}
        run: |
          set -e
          rclone lsf gdrive: --max-depth 0 --log-level ERROR >/dev/null || { echo "‚ùå No puedo listar ORIGEN"; exit 3; }
          if [ -n "$DST_ID" ]; then
            cp "$RCLONE_CONFIG" rclone.dst.conf
            perl -0777 -pe 's/(^root_folder_id = ).*/${1}$ENV{"DST_ID"}/m' -i rclone.dst.conf
            RCLONE_CONFIG=$(pwd)/rclone.dst.conf rclone lsf gdrive: --max-depth 0 --log-level ERROR >/dev/null || { echo "‚ùå No puedo listar DESTINO"; exit 4; }
          fi
          echo "‚úÖ Preflight OK"

      - name: Listado visible de archivos en ORIGEN (no se imprime el ID)
        env:
          RCLONE_CONFIG: ${{ github.workspace }}/rclone.conf
        run: |
          set -e
          echo "üìÑ Contenido (s√≥lo archivos) en la carpeta ORIGEN:"
          rclone lsf gdrive: --files-only --log-level ERROR | sed 's/^/ - /'

      - name: Resolver nombres (input/intro/outro) con tolerancia a extensi√≥n y may√∫sculas
        id: resolve
        env:
          RCLONE_CONFIG: ${{ github.workspace }}/rclone.conf
          IN_NAME: ${{ inputs.input_filename }}
          INTRO_NAME: ${{ inputs.intro_filename }}
          OUTRO_NAME: ${{ inputs.outro_filename }}
        run: |
          set -e
          # Listado en JSON para resolver nombres sin depender de coincidencia exacta
          rclone lsjson gdrive: --files-only --log-level ERROR > files.json
          echo "‚ÑπÔ∏è Total archivos detectados en ORIGEN: $(jq 'length' files.json)"

          resolve() {
            # $1 = nombre introducido por input (con o sin extensi√≥n)
            local needle="$1"
            # Devuelve en stdout el nombre real encontrado en Drive o vac√≠o
            jq -r --arg in "$needle" '
              # Normaliza a min√∫sculas
              def norm(s): s|ascii_downcase;
              # Construye {n: "Nombre.ext", nb: "Nombre"} para cada entrada
              [ .[] | select(.IsDir!=true) | {n:.Name, nb:(.Name|sub("\\.[^.]*$";""))} ] as $items
              |
              # 1) Igualdad exacta (case-insensitive) con nombre completo
              ( $items | map(select(norm(.n) == norm($in))) | if length>0 then .[0].n else null end ) //
              # 2) Igualdad con nombre base (sin extensi√≥n)
              ( $items | map(select(norm(.nb) == norm($in))) | if length>0 then .[0].n else null end ) //
              # 3) Empieza por (√∫til para nombres largos)
              ( $items | map(select(norm(.n) | startswith(norm($in)))) | if length>0 then .[0].n else null end ) //
              # 4) Contiene
              ( $items | map(select(norm(.n) | contains(norm($in)))) | if length>0 then .[0].n else "" end )
            ' files.json
          }

          RES_INPUT="$(resolve "$IN_NAME")"
          RES_INTRO="$(resolve "$INTRO_NAME")"
          RES_OUTRO="$(resolve "$OUTRO_NAME")"

          if [ -z "$RES_INPUT" ]; then
            echo "‚ùå No encuentro el archivo de ENTRADA que corresponda a: '$IN_NAME'"
            echo "üëâ Revisa el listado anterior. Acepto con/sin extensi√≥n y coincidencias parciales."
            exit 5
          fi
          if [ -z "$RES_INTRO" ]; then
            echo "‚ùå No encuentro la INTRO: '$INTRO_NAME'"
            exit 5
          fi
          if [ -z "$RES_OUTRO" ]; then
            echo "‚ùå No encuentro el OUTRO: '$OUTRO_NAME'"
            exit 5
          fi

          echo "input_resuelto=$RES_INPUT" >> $GITHUB_OUTPUT
          echo "intro_resuelto=$RES_INTRO" >> $GITHUB_OUTPUT
          echo "outro_resuelto=$RES_OUTRO" >> $GITHUB_OUTPUT

          echo "‚úÖ Resueltos:"
          echo " - Input: $RES_INPUT"
          echo " - Intro: $RES_INTRO"
          echo " - Outro: $RES_OUTRO"

      - name: Descargar fuentes desde Drive
        env:
          RCLONE_CONFIG: ${{ github.workspace }}/rclone.conf
        run: |
          set -e
          mkdir -p in
          rclone copy "gdrive:${{ steps.resolve.outputs.input_resuelto }}" in/ --log-level ERROR
          rclone copy "gdrive:${{ steps.resolve.outputs.intro_resuelto }}"  in/ --log-level ERROR
          rclone copy "gdrive:${{ steps.resolve.outputs.outro_resuelto }}"  in/ --log-level ERROR

      - name: Detectar par√°metros del v√≠deo principal
        id: probe
        run: |
          set -e
          VFILE="in/${{ steps.resolve.outputs.input_resuelto }}"
          V_CODEC=$(ffprobe -v error -select_streams v:0 -show_entries stream=codec_name -of csv=p=0 "$VFILE")
          WIDTH=$(ffprobe -v error -select_streams v:0 -show_entries stream=width -of csv=p=0 "$VFILE")
          HEIGHT=$(ffprobe -v error -select_streams v:0 -show_entries stream=height -of csv=p=0 "$VFILE")
          FPS_R=$(ffprobe -v error -select_streams v:0 -show_entries stream=r_frame_rate -of csv=p=0 "$VFILE")
          A_CODEC=$(ffprobe -v error -select_streams a:0 -show_entries stream=codec_name -of csv=p=0 "$VFILE" || echo "aac")
          A_SR=$(ffprobe -v error -select_streams a:0 -show_entries stream=sample_rate -of csv=p=0 "$VFILE" || echo "48000")
          A_CH=$(ffprobe -v error -select_streams a:0 -show_entries stream=channels -of csv=p=0 "$VFILE" || echo "2")
          case "$V_CODEC" in
            h264) VLIB=libx264 ;;
            hevc|h265) VLIB=libx265; V_CODEC=hevc ;;
            *) VLIB=libx264; V_CODEC=h264 ;;
          esac
          case "$A_CODEC" in
            aac) ALIB=aac ;; mp3) ALIB=libmp3lame ;; opus) ALIB=libopus ;; *) ALIB=aac; A_CODEC=aac ;;
          esac
          echo "vcodec=$V_CODEC" >> $GITHUB_OUTPUT
          echo "vlib=$VLIB"      >> $GITHUB_OUTPUT
          echo "width=$WIDTH"    >> $GITHUB_OUTPUT
          echo "height=$HEIGHT"  >> $GITHUB_OUTPUT
          echo "fpsr=$FPS_R"     >> $GITHUB_OUTPUT
          echo "acodec=$A_CODEC" >> $GITHUB_OUTPUT
          echo "alib=$ALIB"      >> $GITHUB_OUTPUT
          echo "asr=$A_SR"       >> $GITHUB_OUTPUT
          echo "ach=$A_CH"       >> $GITHUB_OUTPUT

      - name: Adaptar SOLO intro y outro al principal (para favorecer -c copy)
        run: |
          set -e
          VLIB='${{ steps.probe.outputs.vlib }}'
          WIDTH='${{ steps.probe.outputs.width }}'
          HEIGHT='${{ steps.probe.outputs.height }}'
          FPSR='${{ steps.probe.outputs.fpsr }}'
          ALIB='${{ steps.probe.outputs.alib }}'
          ASR='${{ steps.probe.outputs.asr }}'
          ACH='${{ steps.probe.outputs.ach }}'

          ffmpeg -hide_banner -loglevel error -y -i "in/${{ steps.resolve.outputs.intro_resuelto }}" \
            -vf "scale=${WIDTH}:${HEIGHT}:force_original_aspect_ratio=decrease,pad=${WIDTH}:${HEIGHT}:(ow-iw)/2:(oh-ih)/2" \
            -r "$FPSR" -c:v "$VLIB" -pix_fmt yuv420p -c:a "$ALIB" -ar "$ASR" -ac "$ACH" intro_t.mp4

          ffmpeg -hide_banner -loglevel error -y -i "in/${{ steps.resolve.outputs.outro_resuelto }}" \
            -vf "scale=${WIDTH}:${HEIGHT}:force_original_aspect_ratio=decrease,pad=${WIDTH}:${HEIGHT}:(ow-iw)/2:(oh-ih)/2" \
            -r "$FPSR" -c:v "$VLIB" -pix_fmt yuv420p -c:a "$ALIB" -ar "$ASR" -ac "$ACH" outro_t.mp4

      - name: Concatenar (sin recodificar el cuerpo; fallback si falla)
        run: |
          set -e
          printf "file 'intro_t.mp4'\nfile 'in/${{ steps.resolve.outputs.input_resuelto }}'\nfile 'outro_t.mp4'\n" > list.txt
          if ffmpeg -hide_banner -loglevel error -f concat -safe 0 -i list.txt -c copy out.mp4; then
            echo "Concat -c copy OK"
          else
            echo "Param mismatch; recodificando todo (tardar√° m√°s)"
            ffmpeg -hide_banner -loglevel error -f concat -safe 0 -i list.txt \
              -c:v libx264 -preset veryfast -crf 20 -c:a aac -b:a 128k out.mp4
          fi

      - name: Subir salida a Drive DESTINO (o a ORIGEN si no hay destino)
        env:
          RCLONE_CONFIG: ${{ github.workspace }}/rclone.conf
          DST_ID: ${{ secrets.DRIVE_DST_ID }}
        run: |
          set -e
          OUT="${{ inputs.output_basename }}.mp4"
          if [ -n "$DST_ID" ]; then
            cp "$RCLONE_CONFIG" rclone.dst.conf
            perl -0777 -pe 's/(^root_folder_id = ).*/${1}$ENV{"DST_ID"}/m' -i rclone.dst.conf
            RCLONE_CONFIG=$(pwd)/rclone.dst.conf rclone copyto out.mp4 "gdrive:${OUT}" --log-level ERROR
          else
            rclone copyto out.mp4 "gdrive:${OUT}" --log-level ERROR
          fi
